generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
enum FriendshipStatus {
  PENDING
  ACCEPTED
}
model User {
  id                     Int                 @id @default(autoincrement())
  userName               String              @unique
  email                  String              @unique
  password               String
  createdAt              DateTime            @default(now())
  gender                 String?
  avatarUrl              String?
  age                    Int?
  description            String?
  isVerified             Boolean             @default(false)
  verificationExpires    DateTime?
  verificationToken      String?
  customNotifyEnabled    Boolean             @default(false)
  customNotifyLat        Float?
  customNotifyLng        Float?
  lastDeviceLat          Float?
  lastDeviceLng          Float?
  notificationRadiusKm   Int                 @default(30)
  rankCompletedEvents    Int                 @default(0)
  rankUniqueLocations    Int                 @default(0)
  codeExpiresAt          DateTime?
  isPhoneVerified        Boolean             @default(false)
  phoneNumber            String?             @unique
  verificationCode       String?
  isRegistrationComplete Boolean             @default(false)
  dateOfBirth            DateTime?
  eventsCreated          Event[]             @relation("EventCreator")
  eventCompletions       EventCompletion[]
  participatedEvents     EventParticipant[]
  receivedRequests       Friendship[]        @relation("Recipient")
  sentRequests           Friendship[]        @relation("Requester")
  notifications          Notification[]      @relation("UserNotifications")
  pushTokens             PushToken[]
  userInterests          UserInterest[]
  locationVisits         UserLocationVisit[]

  @@index([customNotifyLat, customNotifyLng])
  @@index([lastDeviceLat, lastDeviceLng])
}

model UserRating {
  id        Int      @id @default(autoincrement())
  eventId   Int
  raterId   Int      // kto wystawia ocenę
  rateeId   Int      // kto jest oceniany
  stars     Int      // 1–5
  tags      String[] // lista przymiotników (Postgres TEXT[])

  createdAt DateTime @default(now())

  @@unique([eventId, raterId, rateeId])
}


model Event {
  id                 Int                @id @default(autoincrement())
  location           String
  address            String
  startDate          DateTime
  endDate            DateTime
  createdAt          DateTime           @default(now())
  activity           String
  creatorId          Int
  maxParticipants    Int
  genderBalance      Boolean            @default(false)
  maxAge             Int?
  minAge             Int?
  latitude           Float?
  longitude          Float?
  creatorLatAtCreate Float?
  creatorLngAtCreate Float?
  locationId         String?
  locationKey        String?
  creator            User               @relation("EventCreator", fields: [creatorId], references: [id])
  completions        EventCompletion[]
  eventParticipants  EventParticipant[]

  @@index([latitude, longitude])
  @@index([creatorLatAtCreate, creatorLngAtCreate])
  @@index([locationId])
  @@index([locationKey])
}

model EventParticipant {
  id       Int      @id @default(autoincrement())
  userId   Int
  eventId  Int
  joinedAt DateTime @default(now())
  event    Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId])
  @@unique([eventId, userId])
  @@index([userId])
  @@index([eventId])
}

model EventCompletion {
  id          Int      @id @default(autoincrement())
  userId      Int
  eventId     Int
  locationKey String?
  createdAt   DateTime @default(now())
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
  @@index([locationKey])
}

model UserLocationVisit {
  userId      Int
  locationKey String
  createdAt   DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, locationKey])
  @@index([userId])
  @@index([locationKey])
}

model UserInterest {
  id       Int    @id @default(autoincrement())
  userId   Int
  activity String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model PushToken {
  id        Int           @id @default(autoincrement())
  userId    Int
  token     String
  createdAt DateTime      @default(now())
  platform  Platform?
  tokenType PushTokenType @default(expo)
  updatedAt DateTime      @updatedAt
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, token, tokenType], name: "userId_token_tokenType")
  @@index([userId])
}

model Notification {
  id        Int      @id @default(autoincrement())
  userId    Int
  message   String
  createdAt DateTime @default(now())
  user      User     @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Friendship {
  id          Int              @id @default(autoincrement())
  requesterId Int
  recipientId Int
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime         @default(now())

  recipient   User @relation("Recipient", fields: [recipientId], references: [id], onDelete: Cascade)
  requester   User @relation("Requester", fields: [requesterId], references: [id], onDelete: Cascade)

  // ✅ blokuje duplikaty w tej samej kolejności requester->recipient
  @@unique([requesterId, recipientId])

  // ✅ przyspiesza Twoje query:
  // getFriendRequests: recipientId + status
  // getFriends: requesterId/recipientId + status
  @@index([recipientId, status])
  @@index([requesterId, status])
}


enum PushTokenType {
  expo
  fcm
}

enum Platform {
  android
  ios
  web
}
