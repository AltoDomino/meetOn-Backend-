// =======================================
// Prisma schema (with rankings support)
// =======================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum PushTokenType {
  expo
  fcm
}

enum Platform {
  android
  ios
  web
}

model User {
  id                  Int       @id @default(autoincrement())
  userName            String    @unique
  email               String    @unique
  password            String
  phoneNumber      String?   @unique
  isPhoneVerified  Boolean   @default(false)
  verificationCode String?
   codeExpiresAt    DateTime?  
  createdAt           DateTime  @default(now())
  gender              String?
  avatarUrl           String?
  age                 Int?
  description         String?
  isVerified          Boolean   @default(false)
  verificationToken   String?
  verificationExpires DateTime?

  // --- Preferencje powiadomień / lokalizacje użytkownika ---
  notificationRadiusKm Int     @default(30)
  customNotifyEnabled  Boolean @default(false)
  customNotifyLat      Float?
  customNotifyLng      Float?
  lastDeviceLat        Float?
  lastDeviceLng        Float?

  // --- RANKINGI ---
  rankCompletedEvents Int @default(0) // ile wydarzeń „dociągniętych do końca”
  rankUniqueLocations Int @default(0) // w ilu unikalnych miejscówkach był

  // --- Relacje ---
  eventsCreated      Event[]            @relation("EventCreator")
  userInterests      UserInterest[]
  pushTokens         PushToken[]
  sentRequests       Friendship[]       @relation("Requester")
  receivedRequests   Friendship[]       @relation("Recipient")
  Notification       Notification[]
  participatedEvents EventParticipant[]

  // RANKINGI relacje
  eventCompletions EventCompletion[]
  locationVisits   UserLocationVisit[]

  @@index([customNotifyLat, customNotifyLng])
  @@index([lastDeviceLat, lastDeviceLng])
}

model Event {
  id              Int      @id @default(autoincrement())
  location        String
  address         String
  startDate       DateTime
  endDate         DateTime
  activity        String
  maxParticipants Int
  genderBalance   Boolean  @default(false)
  createdAt       DateTime @default(now())
  minAge          Int?
  maxAge          Int?
  latitude        Float?
  longitude       Float?

  // --- Snapshot lokalizacji twórcy w momencie tworzenia wydarzenia ---
  creatorLatAtCreate Float?
  creatorLngAtCreate Float?

  // --- Identyfikatory lokalizacji dla rankingów ---
  locationId  String? // np. Google Place ID / OSM ID (opcjonalnie)
  locationKey String? // fallback: znormalizowana nazwa/geohash (tworzysz w backendzie)

  // --- Relacje ---
  creatorId         Int
  creator           User               @relation("EventCreator", fields: [creatorId], references: [id])
  eventParticipants EventParticipant[]
  completions       EventCompletion[] // zaliczenia do rankingu

  @@index([latitude, longitude])
  @@index([creatorLatAtCreate, creatorLngAtCreate])
  @@index([locationId])
  @@index([locationKey])
}

model EventParticipant {
  id       Int      @id @default(autoincrement())
  userId   Int
  eventId  Int
  joinedAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([userId, eventId])
  @@unique([eventId, userId])
  @@index([userId])
  @@index([eventId])
}

model EventCompletion {
  id          Int      @id @default(autoincrement())
  userId      Int
  eventId     Int
  locationKey String?
  createdAt   DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([userId, eventId]) // idempotencja: jedno zaliczenie per (user,event)
  @@index([userId])
  @@index([eventId])
  @@index([locationKey])
}

model UserLocationVisit {
  userId      Int
  locationKey String
  createdAt   DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([userId, locationKey]) // unikalna para (user, miejsce)
  @@index([userId])
  @@index([locationKey])
}

model UserInterest {
  id       Int    @id @default(autoincrement())
  userId   Int
  activity String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([userId])
}

model PushToken {
  id        Int           @id @default(autoincrement())
  userId    Int
  token     String
  tokenType PushTokenType @default(expo)
  platform  Platform?
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  // jeden user może mieć różne tokeny, ale nie dwa takie same z tym samym typem
  @@unique([userId, token, tokenType], name: "userId_token_tokenType")
  @@index([userId])
}

model Notification {
  id        Int      @id @default(autoincrement())
  userId    Int
  message   String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([userId])
}

model Friendship {
  id          Int      @id @default(autoincrement())
  requesterId Int
  recipientId Int
  status      String
  createdAt   DateTime @default(now())

  requester User @relation("Requester", fields: [requesterId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  recipient User @relation("Recipient", fields: [recipientId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([requesterId])
  @@index([recipientId])
}
